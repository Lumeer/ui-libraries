import { DataValue } from '../data-value';
import { ConstraintType, ConditionType, ConstraintConfig } from '../model';
import { ConstraintData } from './constraint-data';
export interface Constraint {
    /**
     * Type of this constraint
     */
    type: ConstraintType;
    /**
     * Config used for data value formatting, serialization, validation, etc.
     */
    config: Partial<ConstraintConfig>;
    /**
     * Determine if constraint is visualized simply by text in readonly mode.
     */
    isTextRepresentation?: boolean;
    /**
     * Determine if constraint can be edited directly (i.e. on simple click).
     */
    isDirectlyEditable?: boolean;
    /**
     * Determine if constraint can contain and edit function.
     */
    allowEditFunction?: boolean;
    /**
     * Creates data value based on this constraint.
     */
    createDataValue(value: any, constraintData?: ConstraintData): DataValue;
    /**
     * Creates data value based on this constraint.
     */
    createInputDataValue(inputValue: string, value: any, constraintData?: ConstraintData): DataValue;
    /**
     * Calculates a sum of the given values.
     */
    sum(values: any[], onlyNumeric?: boolean): any;
    /**
     * Calculates an average of the given values.
     */
    avg(values: any[], onlyNumeric?: boolean): any;
    /**
     * Calculates a minimum of the given values.
     */
    min(values: any[], onlyNumeric?: boolean): any;
    /**
     * Calculates a maximum of the given values.
     */
    max(values: any[], onlyNumeric?: boolean): any;
    /**
     * Calculates a median of the given values.
     */
    median(values: any[], onlyNumeric?: boolean): any;
    /**
     * Calculates a median of the given values.
     */
    median(values: any[], onlyNumeric?: boolean): any;
    /**
     * Calculates a count of the given values.
     */
    count(values: any[]): number;
    /**
     * Calculates a unique count of the given values.
     */
    unique(values: any[]): number;
    /**
     * Supported conditions
     */
    conditions(): ConditionType[];
    /**
     * Filters invalid values from data objects
     */
    filterInvalidValues<T extends {
        data: Record<string, any>;
    }>(objects: T[], attributeId: string, constraintData?: ConstraintData): Set<any>;
}
